- Inférieur : FAIT  
--> plutôt implémenter strenght ? (rabbit=1, cat=2...)  //FAIT
- implementer type(rabbit, cat, dog, horse, camel, elephant)  //FAIT
- Implémenter le prédicat Trap (2,2)(2,6)(6,2)(6,6)  //FAIT
- implémenter side(gold, silver)  //FAIT
- Implémenter Gamestate  //FAIT ?
- Autoriser entre 1 et 4 mouvements //FAIT AVEC remainSteps

- Implémenter Get_moves(Moves, gamestate, board) //C  OK
- implémenter Move, faire attention à limiter le nb à 4 et à permettre que les mouvements possibles (celui d'en dessous)  //L je vois pas ce qui faut faire de +
- implementer un predicat qui donne pour une piece en jeu ses différents mouvements possibles
(en fonction de son type, des autres pièces du jeu, de si elle est frozen ou pas, etc)  //C   OK
- implémenter push/pull ? //L  OK
- Implémenter Board //C   OK
- Implémenter frozen  //L OK

- Implémenter le choix libre de placement des pièces au début
- Faire en sorte que les pieces out soient ejectées du jeu   //voir ce que j'ai fait


-Chercher une stratégie de jeu :
https://boardgamegeek.com/thread/110510/arimaa-well-its-way-becoming-classic
https://en.wikibooks.org/wiki/Arimaa/Introduction_to_Strategy

Algo minimax :
http://www.emse.fr/~picard/cours/ai/minimax/

-implémenter NewBoard qui change la position d'une piece dans Board après le choix du premier élément de moves ?
- Comment faire notre min-max ? Sachant que d'un tour à l'autre il faut évaluer comment va jouer le joueur adverse
- supprimer tous les endroits où on a implémenté le code pour l'humain ?
- Faire les prédicats et algo de décision 
  --> win(L, C, silver, Board) :- piece(_,_,rabbit,silver), L=:=7, possMove().  //un des lapins silver a atteint la dernière ligne (camp adverse)
